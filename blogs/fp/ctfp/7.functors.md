---
author: mxtao
date: 2020-03-21
---

[Link to Blog](https://bartoszmilewski.com/2015/01/20/functors/)

[<译> 函子](https://segmentfault.com/a/1190000003954370)

# Functors - 函子

函子是范畴之间的映射。给定两个范畴C与D，函子F可以将C中的对象映射为D中的对象，可以将C中态射映射为D中态射，并保持其结构。若C中有对象a，它在D中的象为Fa；C中有从对象a到b的态射f，其在D中的象为Ff，从Fa到Fb。此外，态射的复合也应当符合直觉的，在范畴C中h是g与f的复合，那么在范畴D中，Fh应当是Fg与Ff的复合。最后，C中的恒等态射被映射为D中的恒等态射。$Fid_a = id_{Fa}$ (`F ida = idFa`) `ida` 是作用于对象a的恒等态射，`idFa`是作用于对象Fa的恒等态射。

函子比常规函数的约束更为严格，函子必须保持范畴的结构。

函子可以做折叠或嵌入的工作。所谓嵌入，就是将一个小的源范畴嵌入到更大的目标范畴中。一个极端的例子，源范畴是个单例范畴——只有一个对象与一个态射（恒等态射）的范畴，从单例范畴映射到任何其他范畴的函子，所做的工作就是在后者中选择一个对象。这完全类似于接受单例集合的态射，这个态射会从目标集合中选择元素。最巨大的折叠函子被称为常函子$\triangle_C$，它将源范畴中的每个对象映射为目标范畴中特定的对象 c，它也可以将源范畴中的每个态射映射为目标范畴中的特定的恒等态射$id_c$，它在行为上像一个黑洞，将所有东西压成一个奇点。在讨论极限与余极限时，我们再来考察这个黑洞函子。

## Functors in Programming - 编程中的函子

> functors that map this category into itself — such functors are called endofunctors.

函子将这个范畴映射为其自身——这样的函子被称为自函子。

### Maybe Functor - Maybe 函子

Maybe 的定义就是将类型 a 映射为类型 Maybe a：`data Maybe a = Nothing | Just a`。

Maybe 本身不是一个类型，它是一个类型构造子（Constructor）。必须向它提供一个类型参数，例如 Int 或 Bool，然后才可以使其变成一个类型。如不果不向 Maybe 提供任何参数，那么它就是一个作用于类型的函数。

一个函子不仅仅只映射对象（在此，是类型），它也映射态射（在此，是函数）。对于任何从 a 到 b 的函数：`f :: a -> b`被 Maybe 函子映射为：`f' :: Maybe a -> Maybe b`。Haskell 以高阶函数的形式实现了一个函子的态射映射部分，这个函数叫 fmap。对于 Maybe 的情况，这个函数的签名如下：`fmap :: (a -> b) -> (Maybe a -> Maybe b)`。通常说fmap**提升**（**Lift**）了一个函数。被提升的函数作用于 Maybe 层次上的值。

为了说明类型构造子 Maybe 携同函数 fmap 共同形成一个函子，不得不证明 fmap 能够维持恒等态射以及态射的复合的存在。所证明的东西，叫做『函子定律』。凡是满足函子定律的函子，必定不会破坏范畴的结构。

### Equational Reasoning - 等式推导

为了证明函子定律，我需要借助等式推导，这也是 Haskell 中常用的证明技巧。它利用了 Haskell 函数基于等式定义这一优势：左侧等于右侧。总是可以用其中一侧替换另一侧，只是有时变量名需要改一下以避免名字冲突。可以将这种替换视为内联一个函数，或者将一个表达式重构为一个函数。这种替换可以从两个方向进行，如果一个函数是基于模式匹配定义的，可以单独使用它的子定义。

先从证明函子对恒等态射的维持开始：`fmap id = id`。要考虑两种情况：Nothing 与 Just。

```haskell
  fmap id Nothing 
= { definition of fmap }
  Nothing 
= { definition of id }
  id Nothing

  fmap id (Just x) 
= { definition of fmap }
  Just (id x) 
= { definition of id }
  Just x
= { definition of id }
  id (Just x)
```

现在来证明 fmap 能够维持态射的复合：`fmap (g . f) = fmap g . fmap f`

```haskell
  fmap (g . f) Nothing 
= { definition of fmap }
  Nothing 
= { definition of fmap }
  fmap g Nothing
= { definition of fmap }
  fmap g (fmap f Nothing)

  fmap (g . f) (Just x)
= { definition of fmap }
  Just ((g . f) x)
= { definition of composition }
  Just (g (f x))
= { definition of fmap }
  fmap g (Just (f x))
= { definition of fmap }
  fmap g (fmap f (Just x))
= { definition of composition }
  (fmap g . fmap f) (Just x)
```
