---
author: mxtao
date: 2020-04-01
---

# Function Type - 函数类型

曾多次提到函数类型，函数类型与其它普通类型有显著不同。以Integer为例，它是整数的集合；Bool是两个元素构成的集合。然而一个函数类型`a->b`的内涵要更大一些，它是从a到b的所有态射构成的集合。从一个对象到另一个对象的所有态射构成的集合，叫hom-集。在集合范畴中，hom-集自身也是个对象。对其它范畴而言，hom-集会形成一个外部范畴，这样的hom-集成为外hom-集。集合的范畴的自引用属性使得函数类型变得有些特殊。但是，至少在某些范畴中，有一种方法可以构造 hom-集这样的对象。这种 hom-集被称为内 hom-集。

## Universal Construction - 泛构造

先着手尝试去构造一个函数类型，或者从广义上说，去构造一个内 hom-集。

可将函数类型视为一种复合类型，因为它描述的是一个参数类型（Argument Type）与结果类型（Result Type）之间的关系。用泛构造定义过积类型与余积类型，现可以用同样技巧来定义函数类型，前提是需给出可以联系三种对象的模式。这三种对象分别是：要构造的函数类型，参数类型及结果类型。

显然，联系这三种类型的模式就是函数应用（Function Application）或求值。对于函数类型，假设存在一个候选者 z（在非集合的范畴中，z 只是个普通的对象），设参数类型为 a（一个对象），函数『应用』可将 z 与 a 构成的序对映射为结果类型 b（一个对象）。现有三个对象，它们中有两个是固定的（一个是参数类型，另一个是结果类型），剩下的那个就是『应用』。『应用』是一种映射，该如何将它融入到我们刚才所建立的模式之中？如果允许查看对象的内部，就可以将一个函数 f（z 的一个元素）与参数 x 封装为序对，然后将这个序对映射为 f x（f 作用于 x，所得结果就是 b 的一个元素）。只是能处理单个的序对 (f, x) 是没有多少意思的，我们要处理的是函数类型的候选者 z 与参数类型 a 的积，即 z×a。这个积是一个对象，可以选择从这个对象到 b 的一个箭头 g 作为态射，g 也就是『应用』。在集合的范畴中，g 就是将每个 (f, x) 映射为 f x 的函数。

这样，就建立起了这样一个模式：对象 z 与对象 a 的积，通过态射 g 被关联到另一个对象 b。

以对象与态射构成的模式为起点，它是一种不精确的查询，通常会命中很多东西。特别是在集合的范畴中，几乎每一样东西都与其他东西具有相关性。可以拮取任意一个对象 z，将其与 a 形成积，再找个函数将积映射为 b（除非 b 是空集）。这样，排名（Ranking）就派上了用场，就是检查一下是不是在函数类型的候选者之间存在唯一的映射——可以因式化泛构造的映射。当且仅当存在一个唯一的从 z' 到 z 的映射，使得 g' 可由 g 的因式来构造，即可判定伴随态射 g（从 z×a 到 b）的 z 比伴随 g' 的候选者 z' 更好。

假设存在态射 h:: z' -> z，我们想获得从 z'×a 到 z×a 的态射。由于积类型本身是一个函子（更确切的说，是二元自函子），因此可以提升一对态射。也就是说，不仅能定义对象的积，也能定义态射的积。由于不需要改变 z'×a 这个积的第二个成员 a，因此我们要提升的态射序对是 (h, id)，其中 id 是作用于 a 的恒等态射。现在我们可以建立『应用』的因式了，将 g' 表示为 g 的因式：`g' = g ∘ (h × id)` 这里，关键之处在于态射积的作用

泛构造的第三个步就是选出最好的那个候选者——称之为 a⇒b（在这里，将它视为一个对象的名字即可，不要与 Haskell 类型类的约束符号混淆，下文会给出其他命名方式）。这个对象伴随的『应用』——从 (a⇒b)×a 到 b 的态射——称之为 eval。如果其他候选者所对应的『应用』g 都能由 eval 被唯一的构造出来，那么 a⇒b 就是最好的那个候选者。

形式定义如下：

一个从 a 到 b 的函数对象是伴随着态射`eval :: ((a⇒b) × a) -> b`的`a⇒b`，它对于伴随着态射`g :: z × a -> b`的任意其他对象 z 而言， 存在唯一的态射`h :: z -> (a⇒b)`， g 可表示为 h 与 eval 所构成的因式：`g = eval ∘ (h × id)`。

虽然不能担保对于某个范畴中的任意的对象 a 与 b 都存在着 a⇒b，但是对于集合的范畴却总是存在着这样的 a⇒b，并且在集合的范畴中，a⇒b 与 Hom-集 Set(a,b) 同构。这也是为何在 Haskell 中我们将函数类型 a -> b 解释为范畴意义上的函数对象 a⇒b 的原因。 